#include "ThinLens.h"

ThinLens::ThinLens() :
  Camera(),
  lens_radius(1.0),
  d(500.0),
  f(74.0),
  zoom(1.0),
  sampler_ptr(new Sampler)
{}


ThinLens::ThinLens(const ThinLens& c) :
  Camera(c),
  lens_radius(c.lens_radius),
  d(c.d),
  f(c.f),
  zoom(c.zoom)
{
  if(c.sampler_ptr)
    sampler_ptr = c.sampler_ptr->clone();
  else
    sampler_ptr = NULL;
}


ThinLens& ThinLens::operator= (const ThinLens& rhs) {
  if (this != &rhs) {
    Camera::operator= (rhs);
    lens_radius = rhs.lens_radius;
    d           = rhs.d;
    f           = rhs.f;
    zoom        = rhs.zoom;

    if (sampler_ptr) {
      delete sampler_ptr;
      sampler_ptr = NULL;
    }

    if (rhs.sampler_ptr)
      sampler_ptr = rhs.sampler_ptr->clone();
  }

  return *this;
}


ThinLens::~ThinLens() {}


ThinLens* ThinLens::clone() const {
  return new ThinLens(*this);
}


void ThinLens::render_scene(const World& w, FILE *fp) {
  RGBColor  L;
  ViewPlane vp(w.vp);
  Ray	    ray;
  int 	    depth = 0;

  Vector2d sp; // sample point in [0, 1] x [0, 1]
  Vector2d pp; // sample point on a pixel
  Vector2d dp; // sample point on a unit disk
  Vector2d lp; // sample point on lens

  fprintf(fp, "%d %d\n", vp.hres, vp.vres);
  vp.s /= zoom;
		
  for (int r = 0; r < vp.vres - 1; r++) // up
    for (int c = 0; c < vp.hres - 1; c++) { // across 					
      L = black;


      for (int n = 0; n < vp.num_samples; ++n) {
        sp = vp.sampler_ptr->sample_unit_square();
        pp(0) = vp.s * (c - vp.hres / 2.0 + sp.x);
        pp(1) = vp.s * (r - vp.vres / 2.0 + sp.y);

        dp = sampler_ptr->sample_unit_disk();
        lp = dp * lens_radius;

        ray.o = eye + lp(0) * u + lp(1) * v;
        ray.d = ray_direction(pp, lp);
        L += w.tracer_ptr->trace_ray(ray, depth);
      }
			
      L /= vp.num_samples;
      L *= exposure_time;
      w.display_pixel(r, c, L, fp);
    } 
}



Vector3d ThinLens::ray_direction(const Vector2d& pixel_point, const Vector2d& lens_point) const {
  Vector2d pp;                   // hit point on local plane
  pp(0) = pixel_point(0) * f / d;
  pp(1) = pixel_point(1) * f / d;

  Vector3d dir( ( pp(0) - lens_point(0) ) * u, ( pp(1) - lens_point(1) ) * v,  - f * w );
  dir.normalize();

  return dir;
}


void ThinLens::set_sampler(Sampler* sp) {
  if (sampler_ptr) {
    delete sampler_ptr;
    sampler_ptr = NULL;
  }

  sampler_ptr = sp;
  sampler_ptr->map_samples_to_unit_disk();
}
